/***************************************************************
 * Copyright (c) 2007 AIRBUS FRANCE. All rights reserved. This
 * program and the accompanying materials are made available
 * under the terms of the Lesser Gnu Public License (LGPL) which
 * accompanies this distribution, and is available
 * at http://www.gnu.org/licenses/lgpl.html
 *
 * Contributors: Laurent Latil (Atos Origin)
 ******************************************************************/
package org.topcased.gpm.instantiation.options;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.OptionBuilder;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.cli.PosixParser;
import org.apache.commons.lang.StringUtils;

/**
 * Class used to handle the command line options.
 * 
 * @author llatil
 */
public final class InstantiateOptions {
    /** If the dynamic model must be generated */
    public final static String AUTO_GENERATE_DYNAMIC_MODEL =
            "DYNAMIC_MODEL_MUST_BE_GENERATED";

    /** LINE_NUMBER */
    private static final int LINE_NUMBER = 20;

    /** Default Admin login. */
    static private final String ADMIN_LOGIN = "admin";

    /** The options. */
    private final Options options = new Options();

    /** The user login. */
    private String userLogin;

    /** The user password. */
    private String userPwd;

    /** The process name. */
    private String processName;

    /** The type name. */
    private String typeName;

    /** The product name. */
    private String productName;

    /** The number of sheets to create automatically. */
    private int number = 0;

    /** The disable extensions. */
    private boolean disableExtensions = false;

    /** The list of filenames. */
    private List<String> filenames = Collections.emptyList();

    /** The disabled extensions. */
    private List<String> disabledExtensions = Collections.emptyList();

    /** The disabled commands. */
    private List<String> disabledCommands = Collections.emptyList();

    /** The extended option strings. */
    private Set<String> extendedOptionStrings = Collections.emptySet();

    /** The init db. */
    private boolean initDb = false;

    /** Generate the dynamic schema part of the db */
    private boolean autoGenerateDynamicDb = true;

    /** Generate the schema of the db including dynamic part */
    private boolean exportDynamicSchema = true;

    static private Collection<AdditionalOption> staticAdditionalOptsDef =
            new LinkedHashSet<AdditionalOption>();

    static public final String DELETE_ACCESS_OPTION = "delete_acl";

    public static final String DELETE_CATEGORY_VALUES_OPTION =
            "delete_catValues";

    public static final String DISABLE_XML_SCHEMA = "disable_schema_parsing";

    static {
        createAdditionalOption(DELETE_ACCESS_OPTION,
                "Delete all access controls defined on an instance");
        createAdditionalOption(DELETE_CATEGORY_VALUES_OPTION,
                "Delete all category values that are not defined in the\n"
                        + "instance definition file");
        createAdditionalOption(DISABLE_XML_SCHEMA,
                "Disable XML schema validation during parsing");
    }

    static void createAdditionalOption(String pName, String pDescr) {
        staticAdditionalOptsDef.add(new AdditionalOption(pName, pDescr));
    }

    /**
     * Constructs a new options container. This class parses the cmd line
     * arguments, validate them, and make the options available through getters
     * functions.
     * 
     * @param pArgs
     *            Command line arguments
     */
    @SuppressWarnings("static-access")
    public InstantiateOptions(String[] pArgs) {

        options.addOption("I", "init", false,
                "First initialization of the database");

        options.addOption("TU", "generate", false,
                "Disable automatic generation of the dynamic data base schema");

        options.addOption("E", "export", false,
                "Export dynamic data base schema");

        options.addOption(OptionBuilder.withLongOpt("user").withDescription(
                "The user login (default to 'admin')").hasArg().withArgName(
                "user").create('U'));
        options.addOption(OptionBuilder.withLongOpt("passwd").withDescription(
                "User password").hasArg().withArgName("password").create('P'));

        options.addOption(OptionBuilder.withLongOpt("processName").withDescription(
                "The name of process to create / update").hasArg().withArgName(
                "instance name").create('N'));

        options.addOption(OptionBuilder.withLongOpt("typeName").withDescription(
                "The name of sheet type to create").hasArg().withArgName(
                "type name").create('T'));
        options.addOption(OptionBuilder.withLongOpt("productName").withDescription(
                "The product of the automatically created sheets").hasArg().withArgName(
                "product name").create('p'));

        options.addOption(
                "n",
                "count",
                true,
                "Create automatically a given number of sheets (random data).\n"
                        + "Note: this option is intended to be used for tests only");

        options.addOption(OptionBuilder.withLongOpt("disabledExtensions").withDescription(
                "Names of disabled extension points (comma separated)\n"
                        + "Note: use 'all' keyword to disable all extensions").withArgName(
                "ext. names").withValueSeparator(',').hasArgs().create('x'));

        options.addOption(OptionBuilder.withLongOpt("disabledCommands").withDescription(
                "List of disabled commands names (comma separated)").withArgName(
                "cmd names").withValueSeparator(',').hasArgs().create('d'));

        options.addOption(OptionBuilder.withLongOpt("options").withDescription(
                "List of additional instantiation options (comma separated)").withArgName(
                "options").withValueSeparator(',').hasArgs().create('o'));

        options.addOption(OptionBuilder.withLongOpt("filename").withDescription(
                "XML file(s) to process").hasArgs().withArgName("filenames").withValueSeparator(
                ' ').create('f'));

        options.addOption("h", "help", false, "Display help usage.");

        parseOptions(pArgs);
    }

    private void checkAdditionalOptions(Collection<String> pOptionStrings) {
        for (String lOpt : pOptionStrings) {
            boolean lOptValid = false;
            for (AdditionalOption lOptionDef : staticAdditionalOptsDef) {
                if (lOptionDef.getOptionName().equals(lOpt)) {
                    lOptValid = true;
                    continue;
                }
            }
            if (!lOptValid) {
                optionError("Invalid additional option '" + lOpt + "'");
            }
        }
    }

    /**
     * Constructs a new instantiate options.
     */
    public InstantiateOptions() {
    }

    /**
     * Check & parse the command line arguments.
     * 
     * @param pArgs
     *            Command line arguments
     */
    private void parseOptions(String[] pArgs) {
        CommandLineParser lParser = new PosixParser();
        CommandLine lCmd = null;
        try {
            lCmd = lParser.parse(options, pArgs);
        }
        catch (ParseException e) {
            System.err.println("Parsing failed.  Reason: " + e.getMessage());
            System.exit(1);
        }

        if (null == lCmd) {
            System.err.println("Cannot parse command line options");
            System.exit(1);

            // Note: This useless return is only used to prevent a 'possible null' warning.
            return;
        }

        if (lCmd.hasOption('h')) {
            displayUsage();
            System.exit(0);
        }

        userPwd = lCmd.getOptionValue('P');
        processName = lCmd.getOptionValue('N');
        typeName = lCmd.getOptionValue('T');
        productName = lCmd.getOptionValue('p');
        userLogin = lCmd.getOptionValue('U', ADMIN_LOGIN);

        initDb = lCmd.hasOption('I');

        autoGenerateDynamicDb = !lCmd.hasOption("TU");
        exportDynamicSchema = lCmd.hasOption('E');

        if (lCmd.hasOption('x')) {
            List<String> lDisabledExtensions =
                    getValues(lCmd.getOptionValues('x'));

            if (lDisabledExtensions.contains("all")) {
                disableExtensions = true;
            }
            else {
                disabledExtensions = lDisabledExtensions;
            }
        }

        if (lCmd.hasOption('d')) {
            disabledCommands = getValues(lCmd.getOptionValues('d'));
        }

        if (lCmd.hasOption('o')) {
            extendedOptionStrings =
                    new LinkedHashSet<String>(
                            Arrays.asList(lCmd.getOptionValues('o')));
            checkAdditionalOptions(extendedOptionStrings);
        }

        if (lCmd.hasOption('f')) {
            filenames = Arrays.asList(lCmd.getOptionValues('f'));
        }

        // Check option invalid combination
        if (initDb) {
            if (null == userPwd) {
                optionError("An initial password for the administrator must be specified.");
            }
        }
        else if (autoGenerateDynamicDb && filenames.isEmpty()) {
            if (null == userPwd) {
                optionError("The password for user login '" + userLogin
                        + "' is required.");
            }
        }
        else if (exportDynamicSchema) {
            if (null == userPwd) {
                optionError("The password for user login '" + userLogin
                        + "' is required.");
            }
        }
        else if (lCmd.hasOption('n')) {
            try {
                number = Integer.parseInt(lCmd.getOptionValue('n'));
            }
            catch (NumberFormatException e) {
                // Keep the number value unchanged (0)
            }
            if (number <= 0) {
                optionError("Invalid number of sheets to create "
                        + "(must be a strictly positive integer)");
            }

            if (null == userPwd) {
                optionError("The password for user login '" + userLogin
                        + "' is required.");
            }

            if (null == processName) {
                optionError("A business process name must be specified.");
            }

            if (null == typeName) {
                optionError("A SheetType name must be specified.");
            }

            if (null == productName) {
                optionError("A product name must be specified.");
            }
        }
        else {
            if (null == userPwd) {
                optionError("The password for user login '" + userLogin
                        + "' is required.");
            }

            if (null == processName) {
                optionError("A business process name must be specified.");
            }
        }
    }

    /**
     * Display the usage help for this program.
     */
    public void displayUsage() {
        PrintWriter lWriter = new PrintWriter(System.out);
        displayUsage(lWriter);
    }

    /**
     * Display the usage help for this program.
     * 
     * @param pWriter
     *            Writer to use for text output.
     */
    public void displayUsage(PrintWriter pWriter) {
        HelpFormatter lFormatter = new HelpFormatter();

        lFormatter.printHelp(pWriter, HelpFormatter.DEFAULT_WIDTH,
                "instantiate", /* header */
                "", options, HelpFormatter.DEFAULT_LEFT_PAD,
                HelpFormatter.DEFAULT_DESC_PAD, /* footer */"");

        lFormatter.printWrapped(pWriter, HelpFormatter.DEFAULT_WIDTH,
                "\nList of additional options: ");
        for (AdditionalOption lAddOpt : staticAdditionalOptsDef) {
            StringBuilder lSb = new StringBuilder();
            lSb.append(' ');
            lSb.append(lAddOpt.getOptionName());
            lSb.append('\t');
            lSb.append(lAddOpt.getDescription());

            lFormatter.printWrapped(pWriter, HelpFormatter.DEFAULT_WIDTH,
                    LINE_NUMBER, lSb.toString());
        }
        pWriter.flush();
    }

    /**
     * Option error.
     * 
     * @param pMsg
     *            the msg
     */
    private void optionError(String pMsg) {
        System.err.println("Error: " + pMsg + "\n");
        displayUsage();
        System.exit(1);
    }

    /**
     * Gets the filename.
     * 
     * @return the filename
     */
    public List<String> getFilenames() {
        return filenames;
    }

    /**
     * Sets the filename.
     * 
     * @param pFilename
     *            the new filename
     */
    public void setFilename(String pFilename) {
        filenames = Collections.singletonList(pFilename);
    }

    /**
     * Checks if is inits the db.
     * 
     * @return true, if is inits the db
     */
    public boolean isInitDb() {
        return initDb;
    }

    /**
     * Checks if is populate db.
     * 
     * @return true, if is populate db
     */
    public boolean isPopulateDb() {
        return number > 0;
    }

    /**
     * Sets the inits the db.
     * 
     * @param pInitDb
     *            the new inits the db
     */
    public void setInitDb(boolean pInitDb) {
        initDb = pInitDb;
    }

    /**
     * Test if the dynamic schema must be generated
     * 
     * @return If the dynamic schema must be generated
     */
    public boolean isAutoGenerateDynamicDb() {
        return autoGenerateDynamicDb;
    }

    /**
     * Set if the dynamic schema must be generated
     * 
     * @param pAutoGenerateDynamicDb
     *            If the dynamic schema must be generated
     */
    public void setAutoGenerateDynamicDb(boolean pAutoGenerateDynamicDb) {
        autoGenerateDynamicDb = pAutoGenerateDynamicDb;
    }

    /**
     * Test if the schema of the db must be exported
     * 
     * @return Id the schema of the db must be exported
     */
    public boolean isExportDynamicSchema() {
        return exportDynamicSchema;
    }

    /**
     * Set if the schema of the db must be exported
     * 
     * @param pExportDynamicSchema
     *            If the schema of the db must be exported
     */
    public void setExportDynamicSchema(boolean pExportDynamicSchema) {
        exportDynamicSchema = pExportDynamicSchema;
    }

    /**
     * Gets the process name.
     * 
     * @return the process name
     */
    public String getProcessName() {
        return processName;
    }

    /**
     * Sets the process name.
     * 
     * @param pProcessName
     *            the new process name
     */
    public void setProcessName(String pProcessName) {
        processName = pProcessName;
    }

    /**
     * Sets the user.
     * 
     * @param pLogin
     *            the login
     * @param pPwd
     *            the pwd
     */
    public void setUser(String pLogin, String pPwd) {
        setUserLogin(pPwd);
        setUserPassword(pPwd);
    }

    /**
     * Gets the user login.
     * 
     * @return the user login
     */
    public String getUserLogin() {
        return userLogin;
    }

    /**
     * Sets the user login.
     * 
     * @param pUserLogin
     *            the new user login
     */
    public void setUserLogin(String pUserLogin) {
        userLogin = pUserLogin;
    }

    /**
     * Gets the user pwd.
     * 
     * @return the user pwd
     */
    public String getUserPwd() {
        return userPwd;
    }

    /**
     * Gets the type name.
     * 
     * @return the type name
     */
    public String getTypeName() {
        return typeName;
    }

    /**
     * Sets the type name.
     * 
     * @param pName
     *            the new type name
     */
    public void setTypeName(String pName) {
        typeName = pName;
    }

    /**
     * Gets the product name.
     * 
     * @return the product name
     */
    public String getProductName() {
        return productName;
    }

    /**
     * Sets the product name.
     * 
     * @param pProductName
     *            the new product name
     */
    public final void setProductName(String pProductName) {
        productName = pProductName;
    }

    /**
     * Gets the auto created sheets count.
     * 
     * @return the auto created sheets count
     */
    public int getAutoCreatedSheetsCount() {
        return number;
    }

    /**
     * Sets the auto created sheets count.
     * 
     * @param pNumber
     *            the number of sheets to create.
     */
    public void setAutoCreatedSheetsCount(int pNumber) {
        number = pNumber;
    }

    /**
     * Sets the user password.
     * 
     * @param pUserPwd
     *            the new user password
     */
    public void setUserPassword(String pUserPwd) {
        userPwd = pUserPwd;
    }

    /**
     * Checks if is syntax checked.
     * 
     * @return true, if is syntax checked
     */
    public boolean isSyntaxChecked() {
        return !hasExtendedOption(InstantiateOptions.DISABLE_XML_SCHEMA);
    }

    /**
     * Checks if is extensions disabled.
     * 
     * @return true, if is extensions disabled
     */
    public boolean isExtensionsDisabled() {
        return disableExtensions;
    }

    /**
     * Sets the extensions disabled.
     * 
     * @param pDisable
     *            the new extensions disabled
     */
    public void setExtensionsDisabled(boolean pDisable) {
        disableExtensions = pDisable;
    }

    /** The Constant FILE_PREFIX. */
    static final String FILE_PREFIX = "@";

    /** The Constant COMMENT_PREFIX. */
    static final String COMMENT_PREFIX = "#";

    /**
     * Gets the values.
     * 
     * @param pOpt
     *            the opt
     * @return the values
     */
    private List<String> getValues(String[] pRawValues) {

        if (null == pRawValues || pRawValues.length == 0) {
            return Collections.emptyList();
        }

        List<String> lResult = new ArrayList<String>();

        for (String lCurrentValue : pRawValues) {
            if (lCurrentValue.startsWith(FILE_PREFIX)) {
                String lFilename =
                        lCurrentValue.substring(FILE_PREFIX.length());

                File lFile = new File(lFilename);
                if (!lFile.exists()) {
                    optionError("File '" + lFilename + "' not found");
                }
                if (!lFile.canRead()) {
                    optionError("Cannot read file '" + lFilename + "'");
                }
                try {
                    InputStream lIs = new FileInputStream(lFile);

                    InputStreamReader lReader = new InputStreamReader(lIs);
                    BufferedReader lBufferedReader =
                            new BufferedReader(lReader);

                    try {
                        String lLineValue;
                        do {
                            lLineValue = lBufferedReader.readLine();
                            if (null != lLineValue) {
                                lLineValue = lLineValue.trim();
                                if (StringUtils.isNotBlank(lLineValue)
                                        && !lLineValue.startsWith(COMMENT_PREFIX)) {
                                    lResult.add(lLineValue);
                                }
                            }
                        } while (lLineValue != null);
                    }
                    catch (IOException e) {
                        optionError("Cannot read file '" + lFilename + "'");
                    }
                    finally {
                        lBufferedReader.close();
                        // NOTE closing the BufferedReader closes the
                        // InputStreamReader so lReader.close();
                        // in not necessary
                        lIs.close();
                    }
                }
                catch (FileNotFoundException e) {
                    optionError("File '" + lFilename + "' not found");
                }
                catch (IOException e) {
                    optionError("Cannot close file '" + lFilename + "'");
                }
            }
            else {
                lResult.add(lCurrentValue);
            }
        }
        return lResult;
    }

    /**
     * Checks for extended option.
     * 
     * @param pExtOption
     *            the ext option
     * @return true, if successful
     */
    public boolean hasExtendedOption(String pExtOption) {
        return extendedOptionStrings.contains(pExtOption);
    }

    /**
     * Gets the disabled extensions.
     * 
     * @return the disabled extensions
     */
    public final List<String> getDisabledExtensions() {
        return disabledExtensions;
    }

    /**
     * Gets the disabled commands.
     * 
     * @return the disabled commands
     */
    public final List<String> getDisabledCommands() {
        return disabledCommands;
    }

    /**
     * Sets the disabled extensions.
     * 
     * @param pDisabledExtensions
     *            the new disabled extensions
     */
    public final void setDisabledExtensions(List<String> pDisabledExtensions) {
        disabledExtensions = pDisabledExtensions;
    }

    /**
     * Sets the disabled commands.
     * 
     * @param pDisabledCommands
     *            the new disabled commands
     */
    public final void setDisabledCommands(List<String> pDisabledCommands) {
        disabledCommands = pDisabledCommands;
    }
}
